/*
 * Spinnaker API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.18.2
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package gate

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// V2CanaryControllerApiService V2CanaryControllerApi service
type V2CanaryControllerApiService service

type apiGetCanaryResultRequest struct {
	ctx                         _context.Context
	apiService                  *V2CanaryControllerApiService
	canaryConfigIdOrExecutionId string
	storageAccountName          *string
}

func (r apiGetCanaryResultRequest) StorageAccountName(storageAccountName string) apiGetCanaryResultRequest {
	r.storageAccountName = &storageAccountName
	return r
}

/*
GetCanaryResult Retrieve a canary result
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param canaryConfigIdOrExecutionId canaryConfigId or canaryExecutionId. In get request, should canaryExecutionId. In post request, should canaryConfigId
@return apiGetCanaryResultRequest
*/
func (a *V2CanaryControllerApiService) GetCanaryResult(ctx _context.Context, canaryConfigIdOrExecutionId string) apiGetCanaryResultRequest {
	return apiGetCanaryResultRequest{
		apiService:                  a,
		ctx:                         ctx,
		canaryConfigIdOrExecutionId: canaryConfigIdOrExecutionId,
	}
}

/*
Execute executes the request
 @return map[string]interface{}
*/
func (r apiGetCanaryResultRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "V2CanaryControllerApiService.GetCanaryResult")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/canaries/canary/{canaryConfigIdOrExecutionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"canaryConfigIdOrExecutionId"+"}", _neturl.QueryEscape(parameterToString(r.canaryConfigIdOrExecutionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.storageAccountName != nil {
		localVarQueryParams.Add("storageAccountName", parameterToString(*r.storageAccountName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetCanaryResultDeprecatedRequest struct {
	ctx                _context.Context
	apiService         *V2CanaryControllerApiService
	canaryConfigId     string
	canaryExecutionId  string
	storageAccountName *string
}

func (r apiGetCanaryResultDeprecatedRequest) StorageAccountName(storageAccountName string) apiGetCanaryResultDeprecatedRequest {
	r.storageAccountName = &storageAccountName
	return r
}

/*
GetCanaryResultDeprecated (DEPRECATED) Retrieve a canary result
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param canaryConfigId canaryConfigId
 * @param canaryExecutionId canaryExecutionId
@return apiGetCanaryResultDeprecatedRequest
*/
func (a *V2CanaryControllerApiService) GetCanaryResultDeprecated(ctx _context.Context, canaryConfigId string, canaryExecutionId string) apiGetCanaryResultDeprecatedRequest {
	return apiGetCanaryResultDeprecatedRequest{
		apiService:        a,
		ctx:               ctx,
		canaryConfigId:    canaryConfigId,
		canaryExecutionId: canaryExecutionId,
	}
}

/*
Execute executes the request
 @return map[string]interface{}
*/
func (r apiGetCanaryResultDeprecatedRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "V2CanaryControllerApiService.GetCanaryResultDeprecated")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/canaries/canary/{canaryConfigId}/{canaryExecutionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"canaryConfigId"+"}", _neturl.QueryEscape(parameterToString(r.canaryConfigId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"canaryExecutionId"+"}", _neturl.QueryEscape(parameterToString(r.canaryExecutionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.storageAccountName != nil {
		localVarQueryParams.Add("storageAccountName", parameterToString(*r.storageAccountName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetMetricSetPairListRequest struct {
	ctx                 _context.Context
	apiService          *V2CanaryControllerApiService
	metricSetPairListId string
	storageAccountName  *string
}

func (r apiGetMetricSetPairListRequest) StorageAccountName(storageAccountName string) apiGetMetricSetPairListRequest {
	r.storageAccountName = &storageAccountName
	return r
}

/*
GetMetricSetPairList Retrieve a metric set pair list
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param metricSetPairListId metricSetPairListId
@return apiGetMetricSetPairListRequest
*/
func (a *V2CanaryControllerApiService) GetMetricSetPairList(ctx _context.Context, metricSetPairListId string) apiGetMetricSetPairListRequest {
	return apiGetMetricSetPairListRequest{
		apiService:          a,
		ctx:                 ctx,
		metricSetPairListId: metricSetPairListId,
	}
}

/*
Execute executes the request
 @return []map[string]interface{}
*/
func (r apiGetMetricSetPairListRequest) Execute() ([]map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "V2CanaryControllerApiService.GetMetricSetPairList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/canaries/metricSetPairList/{metricSetPairListId}"
	localVarPath = strings.Replace(localVarPath, "{"+"metricSetPairListId"+"}", _neturl.QueryEscape(parameterToString(r.metricSetPairListId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.storageAccountName != nil {
		localVarQueryParams.Add("storageAccountName", parameterToString(*r.storageAccountName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v []map[string]interface{}
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiInitiateCanaryRequest struct {
	ctx                         _context.Context
	apiService                  *V2CanaryControllerApiService
	executionRequest            *map[string]interface{}
	canaryConfigIdOrExecutionId string
	application                 *string
	configurationAccountName    *string
	metricsAccountName          *string
	parentPipelineExecutionId   *string
	storageAccountName          *string
}

func (r apiInitiateCanaryRequest) ExecutionRequest(executionRequest map[string]interface{}) apiInitiateCanaryRequest {
	r.executionRequest = &executionRequest
	return r
}

func (r apiInitiateCanaryRequest) Application(application string) apiInitiateCanaryRequest {
	r.application = &application
	return r
}

func (r apiInitiateCanaryRequest) ConfigurationAccountName(configurationAccountName string) apiInitiateCanaryRequest {
	r.configurationAccountName = &configurationAccountName
	return r
}

func (r apiInitiateCanaryRequest) MetricsAccountName(metricsAccountName string) apiInitiateCanaryRequest {
	r.metricsAccountName = &metricsAccountName
	return r
}

func (r apiInitiateCanaryRequest) ParentPipelineExecutionId(parentPipelineExecutionId string) apiInitiateCanaryRequest {
	r.parentPipelineExecutionId = &parentPipelineExecutionId
	return r
}

func (r apiInitiateCanaryRequest) StorageAccountName(storageAccountName string) apiInitiateCanaryRequest {
	r.storageAccountName = &storageAccountName
	return r
}

/*
InitiateCanary Start a canary execution
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param canaryConfigIdOrExecutionId canaryConfigId or canaryExecutionId. In get request, should canaryExecutionId. In post request, should canaryConfigId
@return apiInitiateCanaryRequest
*/
func (a *V2CanaryControllerApiService) InitiateCanary(ctx _context.Context, canaryConfigIdOrExecutionId string) apiInitiateCanaryRequest {
	return apiInitiateCanaryRequest{
		apiService:                  a,
		ctx:                         ctx,
		canaryConfigIdOrExecutionId: canaryConfigIdOrExecutionId,
	}
}

/*
Execute executes the request
 @return map[string]interface{}
*/
func (r apiInitiateCanaryRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "V2CanaryControllerApiService.InitiateCanary")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/canaries/canary/{canaryConfigIdOrExecutionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"canaryConfigIdOrExecutionId"+"}", _neturl.QueryEscape(parameterToString(r.canaryConfigIdOrExecutionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.executionRequest == nil {
		return localVarReturnValue, nil, reportError("executionRequest is required and must be specified")
	}

	if r.application != nil {
		localVarQueryParams.Add("application", parameterToString(*r.application, ""))
	}
	if r.configurationAccountName != nil {
		localVarQueryParams.Add("configurationAccountName", parameterToString(*r.configurationAccountName, ""))
	}
	if r.metricsAccountName != nil {
		localVarQueryParams.Add("metricsAccountName", parameterToString(*r.metricsAccountName, ""))
	}
	if r.parentPipelineExecutionId != nil {
		localVarQueryParams.Add("parentPipelineExecutionId", parameterToString(*r.parentPipelineExecutionId, ""))
	}
	if r.storageAccountName != nil {
		localVarQueryParams.Add("storageAccountName", parameterToString(*r.storageAccountName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.executionRequest
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiInitiateCanaryWithConfigRequest struct {
	ctx                       _context.Context
	apiService                *V2CanaryControllerApiService
	adhocExecutionRequest     *map[string]interface{}
	application               *string
	metricsAccountName        *string
	parentPipelineExecutionId *string
	storageAccountName        *string
}

func (r apiInitiateCanaryWithConfigRequest) AdhocExecutionRequest(adhocExecutionRequest map[string]interface{}) apiInitiateCanaryWithConfigRequest {
	r.adhocExecutionRequest = &adhocExecutionRequest
	return r
}

func (r apiInitiateCanaryWithConfigRequest) Application(application string) apiInitiateCanaryWithConfigRequest {
	r.application = &application
	return r
}

func (r apiInitiateCanaryWithConfigRequest) MetricsAccountName(metricsAccountName string) apiInitiateCanaryWithConfigRequest {
	r.metricsAccountName = &metricsAccountName
	return r
}

func (r apiInitiateCanaryWithConfigRequest) ParentPipelineExecutionId(parentPipelineExecutionId string) apiInitiateCanaryWithConfigRequest {
	r.parentPipelineExecutionId = &parentPipelineExecutionId
	return r
}

func (r apiInitiateCanaryWithConfigRequest) StorageAccountName(storageAccountName string) apiInitiateCanaryWithConfigRequest {
	r.storageAccountName = &storageAccountName
	return r
}

/*
InitiateCanaryWithConfig Start a canary execution with the supplied canary config
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return apiInitiateCanaryWithConfigRequest
*/
func (a *V2CanaryControllerApiService) InitiateCanaryWithConfig(ctx _context.Context) apiInitiateCanaryWithConfigRequest {
	return apiInitiateCanaryWithConfigRequest{
		apiService: a,
		ctx:        ctx,
	}
}

/*
Execute executes the request
 @return map[string]interface{}
*/
func (r apiInitiateCanaryWithConfigRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "V2CanaryControllerApiService.InitiateCanaryWithConfig")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/canaries/canary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.adhocExecutionRequest == nil {
		return localVarReturnValue, nil, reportError("adhocExecutionRequest is required and must be specified")
	}

	if r.application != nil {
		localVarQueryParams.Add("application", parameterToString(*r.application, ""))
	}
	if r.metricsAccountName != nil {
		localVarQueryParams.Add("metricsAccountName", parameterToString(*r.metricsAccountName, ""))
	}
	if r.parentPipelineExecutionId != nil {
		localVarQueryParams.Add("parentPipelineExecutionId", parameterToString(*r.parentPipelineExecutionId, ""))
	}
	if r.storageAccountName != nil {
		localVarQueryParams.Add("storageAccountName", parameterToString(*r.storageAccountName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.adhocExecutionRequest
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiListCanaryResultsByApplicationRequest struct {
	ctx                _context.Context
	apiService         *V2CanaryControllerApiService
	application        string
	limit              *int32
	statuses           *string
	storageAccountName *string
}

func (r apiListCanaryResultsByApplicationRequest) Limit(limit int32) apiListCanaryResultsByApplicationRequest {
	r.limit = &limit
	return r
}

func (r apiListCanaryResultsByApplicationRequest) Statuses(statuses string) apiListCanaryResultsByApplicationRequest {
	r.statuses = &statuses
	return r
}

func (r apiListCanaryResultsByApplicationRequest) StorageAccountName(storageAccountName string) apiListCanaryResultsByApplicationRequest {
	r.storageAccountName = &storageAccountName
	return r
}

/*
ListCanaryResultsByApplication Retrieve a list of an application's canary results
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param application application
@return apiListCanaryResultsByApplicationRequest
*/
func (a *V2CanaryControllerApiService) ListCanaryResultsByApplication(ctx _context.Context, application string) apiListCanaryResultsByApplicationRequest {
	return apiListCanaryResultsByApplicationRequest{
		apiService:  a,
		ctx:         ctx,
		application: application,
	}
}

/*
Execute executes the request
 @return []map[string]interface{}
*/
func (r apiListCanaryResultsByApplicationRequest) Execute() ([]map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "V2CanaryControllerApiService.ListCanaryResultsByApplication")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/canaries/{application}/executions"
	localVarPath = strings.Replace(localVarPath, "{"+"application"+"}", _neturl.QueryEscape(parameterToString(r.application, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}

	localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	if r.statuses != nil {
		localVarQueryParams.Add("statuses", parameterToString(*r.statuses, ""))
	}
	if r.storageAccountName != nil {
		localVarQueryParams.Add("storageAccountName", parameterToString(*r.storageAccountName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v []map[string]interface{}
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiListCredentialsRequest struct {
	ctx        _context.Context
	apiService *V2CanaryControllerApiService
}

/*
ListCredentials Retrieve a list of configured Kayenta accounts
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return apiListCredentialsRequest
*/
func (a *V2CanaryControllerApiService) ListCredentials(ctx _context.Context) apiListCredentialsRequest {
	return apiListCredentialsRequest{
		apiService: a,
		ctx:        ctx,
	}
}

/*
Execute executes the request
 @return []map[string]interface{}
*/
func (r apiListCredentialsRequest) Execute() ([]map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "V2CanaryControllerApiService.ListCredentials")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/canaries/credentials"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v []map[string]interface{}
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiListJudgesRequest struct {
	ctx        _context.Context
	apiService *V2CanaryControllerApiService
}

/*
ListJudges Retrieve a list of all configured canary judges
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return apiListJudgesRequest
*/
func (a *V2CanaryControllerApiService) ListJudges(ctx _context.Context) apiListJudgesRequest {
	return apiListJudgesRequest{
		apiService: a,
		ctx:        ctx,
	}
}

/*
Execute executes the request
 @return []map[string]interface{}
*/
func (r apiListJudgesRequest) Execute() ([]map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "V2CanaryControllerApiService.ListJudges")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/canaries/judges"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v []map[string]interface{}
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiListMetricsServiceMetadataRequest struct {
	ctx                _context.Context
	apiService         *V2CanaryControllerApiService
	filter             *string
	metricsAccountName *string
}

func (r apiListMetricsServiceMetadataRequest) Filter(filter string) apiListMetricsServiceMetadataRequest {
	r.filter = &filter
	return r
}

func (r apiListMetricsServiceMetadataRequest) MetricsAccountName(metricsAccountName string) apiListMetricsServiceMetadataRequest {
	r.metricsAccountName = &metricsAccountName
	return r
}

/*
ListMetricsServiceMetadata Retrieve a list of descriptors for use in populating the canary config ui
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return apiListMetricsServiceMetadataRequest
*/
func (a *V2CanaryControllerApiService) ListMetricsServiceMetadata(ctx _context.Context) apiListMetricsServiceMetadataRequest {
	return apiListMetricsServiceMetadataRequest{
		apiService: a,
		ctx:        ctx,
	}
}

/*
Execute executes the request
 @return []map[string]interface{}
*/
func (r apiListMetricsServiceMetadataRequest) Execute() ([]map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "V2CanaryControllerApiService.ListMetricsServiceMetadata")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/canaries/metadata/metricsService"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	if r.metricsAccountName != nil {
		localVarQueryParams.Add("metricsAccountName", parameterToString(*r.metricsAccountName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v []map[string]interface{}
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
