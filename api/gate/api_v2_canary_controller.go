/*
 * Spinnaker API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.18.2
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package gate

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// V2CanaryControllerApiService V2CanaryControllerApi service
type V2CanaryControllerApiService service

type apiGetCanaryResultUsingGETRequest struct {
	ctx                _context.Context
	apiService         *V2CanaryControllerApiService
	canaryConfigId     string
	canaryExecutionId  string
	storageAccountName *string
}

func (r apiGetCanaryResultUsingGETRequest) StorageAccountName(storageAccountName string) apiGetCanaryResultUsingGETRequest {
	r.storageAccountName = &storageAccountName
	return r
}

/*
GetCanaryResultUsingGET (DEPRECATED) Retrieve a canary result
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param canaryConfigId canaryConfigId
 * @param canaryExecutionId canaryExecutionId
@return apiGetCanaryResultUsingGETRequest
*/
func (a *V2CanaryControllerApiService) GetCanaryResultUsingGET(ctx _context.Context, canaryConfigId string, canaryExecutionId string) apiGetCanaryResultUsingGETRequest {
	return apiGetCanaryResultUsingGETRequest{
		apiService:        a,
		ctx:               ctx,
		canaryConfigId:    canaryConfigId,
		canaryExecutionId: canaryExecutionId,
	}
}

/*
Execute executes the request
 @return map[string]interface{}
*/
func (r apiGetCanaryResultUsingGETRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "V2CanaryControllerApiService.GetCanaryResultUsingGET")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/canaries/canary/{canaryConfigId}/{canaryExecutionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"canaryConfigId"+"}", _neturl.QueryEscape(parameterToString(r.canaryConfigId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"canaryExecutionId"+"}", _neturl.QueryEscape(parameterToString(r.canaryExecutionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.storageAccountName != nil {
		localVarQueryParams.Add("storageAccountName", parameterToString(*r.storageAccountName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetCanaryResultUsingGET1Request struct {
	ctx                _context.Context
	apiService         *V2CanaryControllerApiService
	canaryExecutionId  string
	storageAccountName *string
}

func (r apiGetCanaryResultUsingGET1Request) StorageAccountName(storageAccountName string) apiGetCanaryResultUsingGET1Request {
	r.storageAccountName = &storageAccountName
	return r
}

/*
GetCanaryResultUsingGET1 Retrieve a canary result
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param canaryExecutionId canaryExecutionId
@return apiGetCanaryResultUsingGET1Request
*/
func (a *V2CanaryControllerApiService) GetCanaryResultUsingGET1(ctx _context.Context, canaryExecutionId string) apiGetCanaryResultUsingGET1Request {
	return apiGetCanaryResultUsingGET1Request{
		apiService:        a,
		ctx:               ctx,
		canaryExecutionId: canaryExecutionId,
	}
}

/*
Execute executes the request
 @return map[string]interface{}
*/
func (r apiGetCanaryResultUsingGET1Request) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "V2CanaryControllerApiService.GetCanaryResultUsingGET1")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/canaries/canary/{canaryExecutionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"canaryExecutionId"+"}", _neturl.QueryEscape(parameterToString(r.canaryExecutionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.storageAccountName != nil {
		localVarQueryParams.Add("storageAccountName", parameterToString(*r.storageAccountName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetCanaryResultsByApplicationUsingGETRequest struct {
	ctx                _context.Context
	apiService         *V2CanaryControllerApiService
	application        string
	limit              *int32
	statuses           *string
	storageAccountName *string
}

func (r apiGetCanaryResultsByApplicationUsingGETRequest) Limit(limit int32) apiGetCanaryResultsByApplicationUsingGETRequest {
	r.limit = &limit
	return r
}

func (r apiGetCanaryResultsByApplicationUsingGETRequest) Statuses(statuses string) apiGetCanaryResultsByApplicationUsingGETRequest {
	r.statuses = &statuses
	return r
}

func (r apiGetCanaryResultsByApplicationUsingGETRequest) StorageAccountName(storageAccountName string) apiGetCanaryResultsByApplicationUsingGETRequest {
	r.storageAccountName = &storageAccountName
	return r
}

/*
GetCanaryResultsByApplicationUsingGET Retrieve a list of an application's canary results
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param application application
@return apiGetCanaryResultsByApplicationUsingGETRequest
*/
func (a *V2CanaryControllerApiService) GetCanaryResultsByApplicationUsingGET(ctx _context.Context, application string) apiGetCanaryResultsByApplicationUsingGETRequest {
	return apiGetCanaryResultsByApplicationUsingGETRequest{
		apiService:  a,
		ctx:         ctx,
		application: application,
	}
}

/*
Execute executes the request
 @return []map[string]interface{}
*/
func (r apiGetCanaryResultsByApplicationUsingGETRequest) Execute() ([]map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "V2CanaryControllerApiService.GetCanaryResultsByApplicationUsingGET")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/canaries/{application}/executions"
	localVarPath = strings.Replace(localVarPath, "{"+"application"+"}", _neturl.QueryEscape(parameterToString(r.application, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}

	localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	if r.statuses != nil {
		localVarQueryParams.Add("statuses", parameterToString(*r.statuses, ""))
	}
	if r.storageAccountName != nil {
		localVarQueryParams.Add("storageAccountName", parameterToString(*r.storageAccountName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v []map[string]interface{}
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetMetricSetPairListUsingGETRequest struct {
	ctx                 _context.Context
	apiService          *V2CanaryControllerApiService
	metricSetPairListId string
	storageAccountName  *string
}

func (r apiGetMetricSetPairListUsingGETRequest) StorageAccountName(storageAccountName string) apiGetMetricSetPairListUsingGETRequest {
	r.storageAccountName = &storageAccountName
	return r
}

/*
GetMetricSetPairListUsingGET Retrieve a metric set pair list
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param metricSetPairListId metricSetPairListId
@return apiGetMetricSetPairListUsingGETRequest
*/
func (a *V2CanaryControllerApiService) GetMetricSetPairListUsingGET(ctx _context.Context, metricSetPairListId string) apiGetMetricSetPairListUsingGETRequest {
	return apiGetMetricSetPairListUsingGETRequest{
		apiService:          a,
		ctx:                 ctx,
		metricSetPairListId: metricSetPairListId,
	}
}

/*
Execute executes the request
 @return []map[string]interface{}
*/
func (r apiGetMetricSetPairListUsingGETRequest) Execute() ([]map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "V2CanaryControllerApiService.GetMetricSetPairListUsingGET")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/canaries/metricSetPairList/{metricSetPairListId}"
	localVarPath = strings.Replace(localVarPath, "{"+"metricSetPairListId"+"}", _neturl.QueryEscape(parameterToString(r.metricSetPairListId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.storageAccountName != nil {
		localVarQueryParams.Add("storageAccountName", parameterToString(*r.storageAccountName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v []map[string]interface{}
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiInitiateCanaryUsingPOSTRequest struct {
	ctx                       _context.Context
	apiService                *V2CanaryControllerApiService
	executionRequest          *map[string]interface{}
	canaryConfigId            string
	application               *string
	configurationAccountName  *string
	metricsAccountName        *string
	parentPipelineExecutionId *string
	storageAccountName        *string
}

func (r apiInitiateCanaryUsingPOSTRequest) ExecutionRequest(executionRequest map[string]interface{}) apiInitiateCanaryUsingPOSTRequest {
	r.executionRequest = &executionRequest
	return r
}

func (r apiInitiateCanaryUsingPOSTRequest) Application(application string) apiInitiateCanaryUsingPOSTRequest {
	r.application = &application
	return r
}

func (r apiInitiateCanaryUsingPOSTRequest) ConfigurationAccountName(configurationAccountName string) apiInitiateCanaryUsingPOSTRequest {
	r.configurationAccountName = &configurationAccountName
	return r
}

func (r apiInitiateCanaryUsingPOSTRequest) MetricsAccountName(metricsAccountName string) apiInitiateCanaryUsingPOSTRequest {
	r.metricsAccountName = &metricsAccountName
	return r
}

func (r apiInitiateCanaryUsingPOSTRequest) ParentPipelineExecutionId(parentPipelineExecutionId string) apiInitiateCanaryUsingPOSTRequest {
	r.parentPipelineExecutionId = &parentPipelineExecutionId
	return r
}

func (r apiInitiateCanaryUsingPOSTRequest) StorageAccountName(storageAccountName string) apiInitiateCanaryUsingPOSTRequest {
	r.storageAccountName = &storageAccountName
	return r
}

/*
InitiateCanaryUsingPOST Start a canary execution
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param canaryConfigId canaryConfigId
@return apiInitiateCanaryUsingPOSTRequest
*/
func (a *V2CanaryControllerApiService) InitiateCanaryUsingPOST(ctx _context.Context, canaryConfigId string) apiInitiateCanaryUsingPOSTRequest {
	return apiInitiateCanaryUsingPOSTRequest{
		apiService:     a,
		ctx:            ctx,
		canaryConfigId: canaryConfigId,
	}
}

/*
Execute executes the request
 @return map[string]interface{}
*/
func (r apiInitiateCanaryUsingPOSTRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "V2CanaryControllerApiService.InitiateCanaryUsingPOST")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/canaries/canary/{canaryConfigId}"
	localVarPath = strings.Replace(localVarPath, "{"+"canaryConfigId"+"}", _neturl.QueryEscape(parameterToString(r.canaryConfigId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.executionRequest == nil {
		return localVarReturnValue, nil, reportError("executionRequest is required and must be specified")
	}

	if r.application != nil {
		localVarQueryParams.Add("application", parameterToString(*r.application, ""))
	}
	if r.configurationAccountName != nil {
		localVarQueryParams.Add("configurationAccountName", parameterToString(*r.configurationAccountName, ""))
	}
	if r.metricsAccountName != nil {
		localVarQueryParams.Add("metricsAccountName", parameterToString(*r.metricsAccountName, ""))
	}
	if r.parentPipelineExecutionId != nil {
		localVarQueryParams.Add("parentPipelineExecutionId", parameterToString(*r.parentPipelineExecutionId, ""))
	}
	if r.storageAccountName != nil {
		localVarQueryParams.Add("storageAccountName", parameterToString(*r.storageAccountName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.executionRequest
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiInitiateCanaryWithConfigUsingPOSTRequest struct {
	ctx                       _context.Context
	apiService                *V2CanaryControllerApiService
	adhocExecutionRequest     *map[string]interface{}
	application               *string
	metricsAccountName        *string
	parentPipelineExecutionId *string
	storageAccountName        *string
}

func (r apiInitiateCanaryWithConfigUsingPOSTRequest) AdhocExecutionRequest(adhocExecutionRequest map[string]interface{}) apiInitiateCanaryWithConfigUsingPOSTRequest {
	r.adhocExecutionRequest = &adhocExecutionRequest
	return r
}

func (r apiInitiateCanaryWithConfigUsingPOSTRequest) Application(application string) apiInitiateCanaryWithConfigUsingPOSTRequest {
	r.application = &application
	return r
}

func (r apiInitiateCanaryWithConfigUsingPOSTRequest) MetricsAccountName(metricsAccountName string) apiInitiateCanaryWithConfigUsingPOSTRequest {
	r.metricsAccountName = &metricsAccountName
	return r
}

func (r apiInitiateCanaryWithConfigUsingPOSTRequest) ParentPipelineExecutionId(parentPipelineExecutionId string) apiInitiateCanaryWithConfigUsingPOSTRequest {
	r.parentPipelineExecutionId = &parentPipelineExecutionId
	return r
}

func (r apiInitiateCanaryWithConfigUsingPOSTRequest) StorageAccountName(storageAccountName string) apiInitiateCanaryWithConfigUsingPOSTRequest {
	r.storageAccountName = &storageAccountName
	return r
}

/*
InitiateCanaryWithConfigUsingPOST Start a canary execution with the supplied canary config
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return apiInitiateCanaryWithConfigUsingPOSTRequest
*/
func (a *V2CanaryControllerApiService) InitiateCanaryWithConfigUsingPOST(ctx _context.Context) apiInitiateCanaryWithConfigUsingPOSTRequest {
	return apiInitiateCanaryWithConfigUsingPOSTRequest{
		apiService: a,
		ctx:        ctx,
	}
}

/*
Execute executes the request
 @return map[string]interface{}
*/
func (r apiInitiateCanaryWithConfigUsingPOSTRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "V2CanaryControllerApiService.InitiateCanaryWithConfigUsingPOST")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/canaries/canary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.adhocExecutionRequest == nil {
		return localVarReturnValue, nil, reportError("adhocExecutionRequest is required and must be specified")
	}

	if r.application != nil {
		localVarQueryParams.Add("application", parameterToString(*r.application, ""))
	}
	if r.metricsAccountName != nil {
		localVarQueryParams.Add("metricsAccountName", parameterToString(*r.metricsAccountName, ""))
	}
	if r.parentPipelineExecutionId != nil {
		localVarQueryParams.Add("parentPipelineExecutionId", parameterToString(*r.parentPipelineExecutionId, ""))
	}
	if r.storageAccountName != nil {
		localVarQueryParams.Add("storageAccountName", parameterToString(*r.storageAccountName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.adhocExecutionRequest
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v map[string]interface{}
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiListCredentialsUsingGETRequest struct {
	ctx        _context.Context
	apiService *V2CanaryControllerApiService
}

/*
ListCredentialsUsingGET Retrieve a list of configured Kayenta accounts
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return apiListCredentialsUsingGETRequest
*/
func (a *V2CanaryControllerApiService) ListCredentialsUsingGET(ctx _context.Context) apiListCredentialsUsingGETRequest {
	return apiListCredentialsUsingGETRequest{
		apiService: a,
		ctx:        ctx,
	}
}

/*
Execute executes the request
 @return []map[string]interface{}
*/
func (r apiListCredentialsUsingGETRequest) Execute() ([]map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "V2CanaryControllerApiService.ListCredentialsUsingGET")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/canaries/credentials"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v []map[string]interface{}
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiListJudgesUsingGETRequest struct {
	ctx        _context.Context
	apiService *V2CanaryControllerApiService
}

/*
ListJudgesUsingGET Retrieve a list of all configured canary judges
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return apiListJudgesUsingGETRequest
*/
func (a *V2CanaryControllerApiService) ListJudgesUsingGET(ctx _context.Context) apiListJudgesUsingGETRequest {
	return apiListJudgesUsingGETRequest{
		apiService: a,
		ctx:        ctx,
	}
}

/*
Execute executes the request
 @return []map[string]interface{}
*/
func (r apiListJudgesUsingGETRequest) Execute() ([]map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "V2CanaryControllerApiService.ListJudgesUsingGET")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/canaries/judges"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v []map[string]interface{}
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiListMetricsServiceMetadataUsingGETRequest struct {
	ctx                _context.Context
	apiService         *V2CanaryControllerApiService
	filter             *string
	metricsAccountName *string
}

func (r apiListMetricsServiceMetadataUsingGETRequest) Filter(filter string) apiListMetricsServiceMetadataUsingGETRequest {
	r.filter = &filter
	return r
}

func (r apiListMetricsServiceMetadataUsingGETRequest) MetricsAccountName(metricsAccountName string) apiListMetricsServiceMetadataUsingGETRequest {
	r.metricsAccountName = &metricsAccountName
	return r
}

/*
ListMetricsServiceMetadataUsingGET Retrieve a list of descriptors for use in populating the canary config ui
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return apiListMetricsServiceMetadataUsingGETRequest
*/
func (a *V2CanaryControllerApiService) ListMetricsServiceMetadataUsingGET(ctx _context.Context) apiListMetricsServiceMetadataUsingGETRequest {
	return apiListMetricsServiceMetadataUsingGETRequest{
		apiService: a,
		ctx:        ctx,
	}
}

/*
Execute executes the request
 @return []map[string]interface{}
*/
func (r apiListMetricsServiceMetadataUsingGETRequest) Execute() ([]map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "V2CanaryControllerApiService.ListMetricsServiceMetadataUsingGET")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/canaries/metadata/metricsService"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	if r.metricsAccountName != nil {
		localVarQueryParams.Add("metricsAccountName", parameterToString(*r.metricsAccountName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v []map[string]interface{}
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
